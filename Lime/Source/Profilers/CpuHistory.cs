using System.Collections.Generic;
using Lime.Graphics.Platform;
using Yuzu;

namespace Lime.Profilers
{
	public class CpuHistory
	{
		public class Item
		{
			/// <summary>
			/// Unique identifier for this update.
			/// </summary>
			[YuzuRequired]
			public long UpdateIndex;

			/// <summary>
			/// The frame index that was generated by this update.
			/// </summary>
			[YuzuRequired]
			public long FrameIndex;

			/// <summary>
			/// Elapsed time since the beginning of the previous update.
			/// </summary>
			[YuzuRequired]
			public float DeltaTime;

			/// <summary>
			/// The Private Bytes counter indicates the total amount of memory that a
			/// process has allocated, not including memory shared with other processes.<para />
			/// The value is written at the end of the update.<para />
			/// For details see https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/using-performance-monitor-to-find-a-user-mode-memory-leak.
			/// </summary>
			[YuzuRequired]
			public int Memory;

			/// <summary>
			/// The number of garbage collections since the previous update for 0 generation.<para />
			/// The value is written at the end of the update.<para />
			/// For details see https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/performance-counters#memory-performance-counters.
			/// </summary>
			[YuzuRequired]
			public int GcGen0;

			/// <summary>
			/// The number of garbage collections since the previous update for 1 generation.<para />
			/// The value is written at the end of the update.<para />
			/// For details see https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/performance-counters#memory-performance-counters.
			/// </summary>
			[YuzuRequired]
			public int GcGen1;

			/// <summary>
			/// The number of garbage collections since the previous update for 2 generation.<para />
			/// The value is written at the end of the update.<para />
			/// For details see https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/performance-counters#memory-performance-counters.
			/// </summary>
			[YuzuRequired]
			public int GcGen2;

			/// <summary>
			/// Displays the percentage of elapsed time that was spent performing a garbage collection since the last garbage collection cycle.<para />
			/// The value is written at the end of the update.<para />
			/// The value in the range from 0 to 100.<para />
			/// For details see https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/performance-counters#memory-performance-counters.
			/// </summary>
			[YuzuRequired]
			public float GcTimePercent;

			/// <summary>
			/// Time spent by each node.
			/// </summary>
			[YuzuRequired]
			public List<CpuUsage> NodesResults = new List<CpuUsage>();

			public Item Reset()
			{
				DeltaTime = 0;
				foreach (var r in NodesResults) {
					r.Free();
				}
				NodesResults.Clear();
				return this;
			}

			/// <summary>
			/// Copy without NodesResults.
			/// </summary>
			public Item LightweightClone() => new Item {
				DeltaTime      = DeltaTime,
				FrameIndex     = FrameIndex,
				UpdateIndex    = UpdateIndex,
				Memory         = Memory,
				GcGen0         = GcGen0,
				GcGen1         = GcGen1,
				GcGen2         = GcGen2,
				GcTimePercent  = GcTimePercent
			};
		}

		protected readonly Item[] items;

		private Item freeItem;
		private long protectedIndex;

		/// <summary>
		/// The last profiled update.
		/// </summary>
		public Item LastUpdate { get; protected set; }

		/// <summary>
		/// The total number of profiled updates from the moment the engine starts.
		/// </summary>
		public long ProfiledUpdatesCount { get; protected set; }

		public CpuHistory()
		{
			freeItem = new Item();
			protectedIndex = -1;
			items = new Item[GpuHistory.HistoryFramesCount];
			for (int i = 0; i < items.Length; i++) {
				items[i] = new Item();
			}
		}

		public Item GetUpdate(long index) => items[index % items.Length];

		public bool IsUpdateIndexValid(long index) =>
			index > 0 &&
			index < ProfiledUpdatesCount &&
			index > ProfiledUpdatesCount - GpuHistory.HistoryFramesCount;

		/// <summary>
		/// Ensures that the update is not reset.
		/// </summary>
		/// <remarks>
		/// Only one update can be locked at a time.
		/// Previous update will be automatically unlocked.
		/// </remarks>
		public bool TryLockUpdate(long updateIndex)
		{
			if (IsUpdateIndexValid(updateIndex)) {
				protectedIndex = updateIndex % items.Length;
				return true;
			} else {
				return false;
			}
		}

		protected Item SafeResetUpdate(long updateIndex)
		{
			long itemIndex = updateIndex % items.Length;
			if (itemIndex == protectedIndex) {
				var protectedUpdate = items[itemIndex];
				items[itemIndex] = freeItem.Reset();
				freeItem = protectedUpdate;
				protectedIndex = -1;
			}
			return items[itemIndex].Reset();
		}
	}
}
